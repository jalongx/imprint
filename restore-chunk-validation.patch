diff --git a/restore.c b/restore.c
index 1234567..abcdef0 100644
--- a/restore.c
+++ b/restore.c
@@ -20,6 +20,8 @@ typedef struct {
     char compression[64];
     bool chunked;
     int chunk_count;
+    int chunk_size_mb;      /* NEW */
+    /* chunk_count already existed but was not parsed */
     bool valid;
 } MetadataInfo;

@@ -118,6 +120,28 @@ load_metadata_or_exit(const char *image_base, MetadataInfo *meta)
             continue;
         }

+        /* chunk_count */
+        p = strstr(line, "\"chunk_count\"");
+        if (p) {
+            p = strchr(p, ':');
+            if (p) meta->chunk_count = atoi(p + 1);
+            continue;
+        }
+
+        /* chunk_size_mb */
+        p = strstr(line, "\"chunk_size_mb\"");
+        if (p) {
+            p = strchr(p, ':');
+            if (p) meta->chunk_size_mb = atoi(p + 1);
+            continue;
+        }
     }

@@ -150,6 +174,78 @@ load_metadata_or_exit(const char *image_base, MetadataInfo *meta)
     return false;
 }

+/* -------------------------------------------------------------
+ * Validate chunk set based on metadata
+ * ------------------------------------------------------------- */
+static bool
+validate_chunk_set(const char *base_image, const MetadataInfo *meta)
+{
+    if (!meta->chunked)
+        return true;   /* single-file image */
+
+    if (meta->chunk_count <= 0) {
+        ui_error("Metadata indicates a chunked image, but chunk_count is invalid.\n"
+                 "Restore cannot continue.");
+        return false;
+    }
+
+    /* Split directory + filename */
+    const char *slash = strrchr(base_image, '/');
+    const char *fname = base_image;
+    char dir[1024];
+
+    if (slash) {
+        size_t dlen = (size_t)(slash - base_image);
+        if (dlen >= sizeof(dir))
+            dlen = sizeof(dir) - 1;
+        memcpy(dir, base_image, dlen);
+        dir[dlen] = '\0';
+        fname = slash + 1;
+    } else {
+        strcpy(dir, ".");
+    }
+
+    /* Validate each expected chunk */
+    for (int i = 0; i < meta->chunk_count; i++) {
+        char chunk_path[2048];
+        snprintf(chunk_path, sizeof(chunk_path),
+                 "%s/%s.%03d",
+                 dir, fname, i);
+
+        struct stat st;
+        if (stat(chunk_path, &st) != 0) {
+            char msg[512];
+            snprintf(msg, sizeof(msg),
+                     "Missing chunk file:\n\n"
+                     "    %s\n\n"
+                     "Expected %d chunks based on metadata.\n"
+                     "Restore cannot continue.",
+                     chunk_path,
+                     meta->chunk_count);
+            ui_error(msg);
+            return false;
+        }
+    }
+
+    return true;
+}
+
 /* -------------------------------------------------------------
  * Interactive restore flow
  * ------------------------------------------------------------- */
@@ -175,6 +271,12 @@ restore_run_interactive(void)
         return false;
     }

+    /* 3a. Validate chunk set */
+    if (!validate_chunk_set(base_image, &meta)) {
+        free(selected_path);
+        return false;
+    }
+
     /* 4. Choose target partition */
     char *device = ui_choose_partition_with_title(
         "Select destination partition for restore",
@@ -330,6 +432,12 @@ bool restore_run_cli(const char *image_path,
         return false;
     }

+    /* Validate chunk set */
+    if (!validate_chunk_set(base_image, &meta)) {
+        return false;
+    }
+
     /* ---------------------------------------------------------
      * 3. Validate target device exists
      * --------------------------------------------------------- */
